-- Generated by Ora2Pg, the Oracle database Schema converter, version 25.0
-- Copyright 2000-2025 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=10.174.11.5;sid=upeu;port=1521

SET client_encoding TO 'UTF8';

SET search_path = david,public;
\set ON_ERROR_STOP ON

CREATE OR REPLACE PACKAGE       PK_PROCEDURE AS
    PROCEDURE SP_STUDENT_HAS_NO_DEBT(
        P_PERSON_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR);
    PROCEDURE SP_STUDENT_TOOK_ENGLISH(
        P_STUDENT_PLAN_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR);
    PROCEDURE SP_STUDENT_TOOK_PRACTICE(
        P_STUDENT_PLAN_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR);
    PROCEDURE SP_FULL_ACADEMIC_PROGRAM(
        P_STUDENT_PLAN_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR);
    PROCEDURE SP_VALIDATE_PROCEDURE_TYPE(
        P_PERSON_ID IN NUMBER,
        P_PROCEDURE_TYPE_ID IN NUMBER,
        P_PARAMS IN VARCHAR2,
        P_CURSOR OUT SYS_REFCURSOR);
    PROCEDURE SP_EVALUATION_REQUIREMENT(
        P_PERSONAL_PROCEDURE_ID IN NUMBER,
        P_PROCEDURE_TYPE_ID IN NUMBER);
    PROCEDURE SP_INSERT_PARAM_PROCEDURE(
        P_PERSONAL_PROCEDURE_ID IN NUMBER,
        P_PARAMS IN VARCHAR2);
    PROCEDURE SP_INIT_STATE(
        P_PERSONAL_PROCEDURE_ID IN NUMBER);
    FUNCTION
        FC_PROCEDURE_BUILD(
        P_PROCEDURE_ID IN NUMBER,
        P_PARAMS IN VARCHAR2)
        RETURN VARCHAR2;
    FUNCTION
        FC_PROCEDURE_PERCENTAGE(
        P_PERSONAL_PROCEDURE_ID IN NUMBER)
        RETURN NUMBER;
    FUNCTION
        FC_EXTRACT_PARAMETERS(
        P_PROCEDURE_TYPE_ID IN NUMBER)
        RETURN VARCHAR2;
    FUNCTION
        FC_EXTRACT_FILES(
        P_PROCEDURE_TYPE_ID IN NUMBER)
        RETURN VARCHAR2;
    FUNCTION
        FC_EXTRACT_VALUE_JSON(
        P_PARAMS IN VARCHAR2,
        P_PARAMETER_ID IN VARCHAR2)
        RETURN VARCHAR2;
    FUNCTION
        FC_STUDENT_PLAN(
        P_PERSON_ID IN NUMBER,
        P_STUDENT_PLAN_ID IN NUMBER)
        RETURN VARCHAR2;
    FUNCTION FC_HAS_STORED_PROCEDURE(
        P_PROCEDURE_TYPE_ID IN NUMBER)
        RETURN NUMBER;

END PK_PROCEDURE;


CREATE OR REPLACE PACKAGE BODY       PK_PROCEDURE AS

    PROCEDURE SP_STUDENT_HAS_NO_DEBT(
        P_PERSON_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR) AS
        P_TOTAL NUMBER := 0;
        P_STATUS
                NUMBER(1);
        P_MESSAGE
                VARCHAR2(200);
    BEGIN


        SELECT NVL((SELECT SUBSTR(DE, 4) monto
                    FROM (SELECT DAVID.FT_DEUDA_ALUMNO(P_PERSON_ID, TO_NUMBER(TO_CHAR(SYSDATE, 'YYYY'))) DE FROM DUAL)
                    WHERE SUBSTR(DE, 0, 2) = '01'), 0)
        INTO P_TOTAL
        FROM DUAL;


        IF
            (P_TOTAL > 0) THEN
            P_STATUS := 0;
            P_MESSAGE
                := 'Requisito no aprobado, tiene una deuda de S/. ' || P_TOTAL || '.';
        ELSE
            P_STATUS := 1;
            P_MESSAGE
                := 'Requisito aprobado.';
        END IF;

        OPEN P_CURSOR FOR
            SELECT P_STATUS as status, P_MESSAGE as message
            FROM DUAL;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_STUDENT_HAS_NO_DEBT;

    PROCEDURE SP_STUDENT_TOOK_ENGLISH(
        P_STUDENT_PLAN_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR)
    AS
        P_RET VARCHAR2(200) := '';
        P_STATUS
              NUMBER(1);
        P_MESSAGE
              CLOB;
    BEGIN


        SELECT LISTAGG(TC.NOMBRE, ', ') WITHIN GROUP (ORDER BY TC.ORDEN)
        INTO P_RET
        FROM DAVID.ACAD_ALUMNO_PLAN AAP
                 INNER JOIN DAVID.ACAD_PLAN_PROGRAMA APP
                            ON AAP.ID_PLAN_PROGRAMA = APP.ID_PLAN_PROGRAMA
                 INNER JOIN DAVID.ACAD_CANDADO_PROGRAMA ACP ON APP.ID_PROGRAMA_ESTUDIO = ACP.ID_PROGRAMA_ESTUDIO
                 INNER JOIN DAVID.TIPO_CANDADO TC ON ACP.ID_TIPO_CANDADO = TC.ID_TIPO_CANDADO
        WHERE AAP.ID_ALUMNO_PLAN = P_STUDENT_PLAN_ID
          AND AAP.ESTADO = 1
          AND NOT EXISTS (SELECT *
                          FROM DAVID.ACAD_CANDADO AC
                          WHERE AAP.ID_PERSONA = AC.ID_PERSONA
                            AND TC.ID_TIPO_CANDADO = AC.ID_TIPO_CANDADO
                            AND AC.ESTADO = 1);

        IF
            P_RET IS NOT NULL THEN
            P_STATUS := 0;
            P_MESSAGE
                := 'Requisito no aprobado, requiere ' || P_RET || '.';
        ELSE
            P_STATUS := 1;
            P_MESSAGE
                := 'Requisito aprobado.';
        END IF;

        OPEN P_CURSOR FOR
            SELECT P_STATUS as status, P_MESSAGE as message
            FROM DUAL;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_STUDENT_TOOK_ENGLISH;

    PROCEDURE SP_STUDENT_TOOK_PRACTICE(
        P_STUDENT_PLAN_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR)
    AS
        P_RET NUMBER := 0;
        P_STATUS
              NUMBER(1);
        P_MESSAGE
              VARCHAR2(200);
    BEGIN


        SELECT (CASE
                    WHEN EXISTS(SELECT PA.ID_PPP_ALUMNO
                                FROM DAVID.PPP_ALUMNO PA
                                WHERE PA.ID_ALUMNO_PLAN = P_STUDENT_PLAN_ID
                                  AND PA.CUMPLIO = 1) THEN 1
                    ELSE 0 END)
        INTO P_RET
        FROM DUAL;

        IF
            P_RET = 0 THEN
            P_STATUS := 0;
            P_MESSAGE
                :=
                    'Requisito no aprobado, no se cumplió con las prácticas preprofesionales o no fueron registradas.';
        ELSE
            P_STATUS := 1;
            P_MESSAGE
                := 'Requisito aprobado.';
        END IF;

        OPEN P_CURSOR FOR
            SELECT P_STATUS as status, P_MESSAGE as message
            FROM DUAL;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_STUDENT_TOOK_PRACTICE;

    PROCEDURE SP_FULL_ACADEMIC_PROGRAM(
        P_STUDENT_PLAN_ID IN NUMBER,
        P_CURSOR OUT SYS_REFCURSOR)
    AS
        P_RET NUMBER := 0;
        P_STATUS
              NUMBER(1);
        P_MESSAGE
              VARCHAR2(200);
    BEGIN

        SELECT DAVID.FT_GRADUADO_PLAN(AAP.ID_PERSONA, AAP.ID_PLAN_PROGRAMA)
        INTO P_RET
        FROM DAVID.ACAD_ALUMNO_PLAN AAP
        WHERE AAP.ID_ALUMNO_PLAN = P_STUDENT_PLAN_ID;


        IF
            P_RET = 0 THEN
            P_STATUS := 1;
            P_MESSAGE
                := 'Requisito aprobado.';
        ELSE
            P_STATUS := 0;
            P_MESSAGE
                := 'Requisito no aprobado.';
        END IF;

        OPEN P_CURSOR FOR
            SELECT P_STATUS as status, P_MESSAGE as message
            FROM DUAL;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_FULL_ACADEMIC_PROGRAM;

    PROCEDURE SP_VALIDATE_PROCEDURE_TYPE(
        P_PERSON_ID IN NUMBER, P_PROCEDURE_TYPE_ID IN NUMBER, P_PARAMS IN VARCHAR2,
        P_CURSOR OUT SYS_REFCURSOR)
    AS
        P_CURSOR_PRO SYS_REFCURSOR;
        P_PROCEDURE
                     VARCHAR2(2000) := '';
        P_SQL
                     VARCHAR2(2500) := '';
        P_SQL_ROW
                     CLOB;
        P_STATUS
                     NUMBER         := 0;
        P_MESSAGE
                     VARCHAR2(200)  := '';

    BEGIN
        FOR P_REQ IN (SELECT ROWNUM AS RN, BAS.*
                      FROM (SELECT TR.ID_REQUISITO,
                                   TR.ID_PROCEDIMIENTO,
                                   TR.NOMBRE,
                                   TTR.CODIGO AS TIPO,
                                   TTV.CODIGO AS VALIDACION,
                                   TP.ESTADO  AS ESTADO_PROC,
                                   TP.CODIGO,
                                   RET.APROBADO
                            FROM DAVID.TR_TIPO_TRAMITE_REQUISITO TTTR
                                     INNER JOIN DAVID.TR_REQUISITO TR ON TTTR.ID_REQUISITO = TR.ID_REQUISITO
                                     INNER JOIN DAVID.TR_TIPO_REQUISITO TTR
                                                ON TR.ID_TIPO_REQUISITO = TTR.ID_TIPO_REQUISITO
                                     INNER JOIN DAVID.TR_TIPO_VALIDACION TTV
                                                ON TR.ID_TIPO_VALIDACION = TTV.ID_TIPO_VALIDACION
                                     LEFT JOIN DAVID.TR_PROCEDIMIENTO TP ON TR.ID_PROCEDIMIENTO = TP.ID_PROCEDIMIENTO
                                     LEFT JOIN (SELECT TTP.ID_PERSONA,
                                                       TTP.ID_TIPO_TRAMITE,
                                                       TTE.ID_REQUISITO,
                                                       TTE.APROBADO
                                                FROM DAVID.TR_TRAMITE_PERSONA TTP
                                                         INNER JOIN DAVID.TR_TRAMITE_EVALUACION TTE
                                                                    ON TTP.ID_TRAMITE_PERSONA = TTE.ID_TRAMITE_PERSONA) RET
                                               ON RET.ID_PERSONA = P_PERSON_ID AND
                                                  RET.ID_TIPO_TRAMITE = TTTR.ID_TIPO_TRAMITE AND
                                                  RET.ID_REQUISITO = TR.ID_REQUISITO
                            WHERE TTTR.ID_TIPO_TRAMITE = P_PROCEDURE_TYPE_ID
                              AND TTTR.ESTADO = 1
                              AND TR.ESTADO = 1
                            ORDER BY TTTR.ORDEN) BAS)
            LOOP

                IF P_REQ.RN > 1 THEN
                    P_SQL_ROW := P_SQL_ROW || ' UNION ';
                END IF;


                IF
                    P_REQ.APROBADO = 1 THEN
                    P_STATUS := 1;
                    P_MESSAGE
                        := 'Requisito aprobado.';
                ELSE

                    IF P_REQ.ID_PROCEDIMIENTO IS NOT NULL AND P_REQ.ESTADO_PROC = 1 AND P_REQ.TIPO = 'VALIDATION' THEN

                        P_PROCEDURE := DAVID.PK_PROCEDURE.FC_PROCEDURE_BUILD(P_REQ.ID_PROCEDIMIENTO, P_PARAMS);

                        IF
                            P_PROCEDURE IS NOT NULL THEN

                            P_SQL := 'BEGIN ' || P_PROCEDURE || '; END;';


                            EXECUTE IMMEDIATE P_SQL USING OUT P_CURSOR_PRO;

                            LOOP
                                FETCH P_CURSOR_PRO INTO P_STATUS, P_MESSAGE;
                                EXIT
                                    WHEN P_CURSOR_PRO%NOTFOUND;
                            END LOOP;

                            CLOSE P_CURSOR_PRO;


                        ELSE
                            P_STATUS := 0;
                            P_MESSAGE
                                := 'Procedimiento de validación no encontrado.';
                        END IF;

                    ELSE

                        IF P_REQ.TIPO = 'DOCUMENTATION' AND P_REQ.VALIDACION = 'REQUEST' THEN
                            P_STATUS := 1;
                            P_MESSAGE
                                := 'Requisito aprobado, validacion del adjunto en solicitud.';
                        ELSE
                            P_STATUS := 0;
                            P_MESSAGE
                                := 'Requisito no aprobado por tipo y estado del procedimiento.';
                        END IF;


                    END IF;

                END IF;

                P_SQL_ROW
                    := P_SQL_ROW || 'SELECT ''' || P_REQ.NOMBRE || ''' AS REQUISITO, ''' || P_STATUS ||
                       ''' AS ESTADO,  ''' || P_MESSAGE || ''' AS MENSAJE FROM DUAL';

            END LOOP;

        OPEN P_CURSOR FOR P_SQL_ROW;


    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_VALIDATE_PROCEDURE_TYPE;

    PROCEDURE SP_EVALUATION_REQUIREMENT(
        P_PERSONAL_PROCEDURE_ID IN NUMBER,
        P_PROCEDURE_TYPE_ID IN NUMBER)
    AS
    BEGIN

        FOR P_RET IN (SELECT ROWNUM AS ORDEN, RET.*
                      FROM (SELECT TR.ID_REQUISITO, TR.NOMBRE
                            FROM DAVID.TR_TIPO_TRAMITE_REQUISITO TTTR
                                     INNER JOIN DAVID.TR_REQUISITO TR ON TTTR.ID_REQUISITO = TR.ID_REQUISITO
                            WHERE TTTR.ID_TIPO_TRAMITE = P_PROCEDURE_TYPE_ID
                              AND TTTR.ESTADO = 1
                              AND TR.ESTADO = 1
                            ORDER BY TTTR.ORDEN) RET)
            LOOP

                MERGE INTO DAVID.TR_TRAMITE_EVALUACION t
                USING (SELECT P_PERSONAL_PROCEDURE_ID AS ID_TRAMITE_PERSONA,
                              P_RET.ID_REQUISITO      AS ID_REQUISITO,
                              P_RET.NOMBRE            AS REQUISITO,
                              P_RET.ORDEN             AS ORDEN
                       FROM DUAL) s
                ON (t.ID_TRAMITE_PERSONA = s.ID_TRAMITE_PERSONA AND T.ID_REQUISITO = S.ID_REQUISITO)
                WHEN NOT MATCHED THEN
                    INSERT (t.ID_TRAMITE_PERSONA, t.ID_REQUISITO, T.REQUISITO, T.ORDEN)
                    VALUES (s.ID_TRAMITE_PERSONA, s.ID_REQUISITO, S.REQUISITO, S.ORDEN);

            END LOOP;


    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_EVALUATION_REQUIREMENT;

    PROCEDURE SP_INSERT_PARAM_PROCEDURE(
        P_PERSONAL_PROCEDURE_ID IN NUMBER,
        P_PARAMS IN VARCHAR2)
    AS
    BEGIN

        IF
            P_PERSONAL_PROCEDURE_ID IS NOT NULL AND P_PARAMS IS NOT NULL THEN


            -- INSERT PARAMS PROCEDURE
            FOR PP IN (SELECT TTP.ID_TRAMITE_PERSONA,
                              TP.ID_PROCEDIMIENTO,
                              TPP.ID_PARAMETRO,
                              DAVID.PK_PROCEDURE.FC_EXTRACT_VALUE_JSON(
                                      P_PARAMS,
                                      TPP.ID_PARAMETRO) AS VALOR,
                              TPP.ORDEN
                       FROM DAVID.TR_TRAMITE_PERSONA TTP
                                INNER JOIN DAVID.TR_TIPO_TRAMITE TTT ON TTP.ID_TIPO_TRAMITE = TTT.ID_TIPO_TRAMITE
                                INNER JOIN DAVID.TR_PROCEDIMIENTO TP ON TTT.ID_PROCEDIMIENTO = TP.ID_PROCEDIMIENTO
                                INNER JOIN DAVID.TR_PROCEDIMIENTO_PARAMETRO TPP
                                           ON TP.ID_PROCEDIMIENTO = TPP.ID_PROCEDIMIENTO
                       WHERE TTP.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID
                       ORDER BY TPP.ORDEN)
                LOOP

                    MERGE INTO DAVID.TR_TRAMITE_PARAMETRO A
                    USING (SELECT P_PERSONAL_PROCEDURE_ID    AS ID_TRAMITE_PERSONA,
                                  PP.ID_PROCEDIMIENTO        AS ID_PROCEDIMIENTO,
                                  PP.ID_PARAMETRO            AS ID_PARAMETRO,
                                  REPLACE(PP.VALOR, '"', '') AS VALOR,
                                  PP.ORDEN                   AS ORDEN
                           FROM DUAL) B
                    ON (A.ID_TRAMITE_PERSONA = B.ID_TRAMITE_PERSONA AND A.ID_PROCEDIMIENTO = B.ID_PROCEDIMIENTO AND
                        A.ID_PARAMETRO = B.ID_PARAMETRO)
                    WHEN MATCHED THEN
                        UPDATE
                        SET A.VALOR = B.VALOR,
                            A.ORDEN = B.ORDEN
                    WHEN NOT MATCHED THEN
                        INSERT
                        (A.ID_TRAMITE_PERSONA,
                         A.ID_PROCEDIMIENTO,
                         A.ID_PARAMETRO,
                         A.VALOR,
                         A.ORDEN)
                        VALUES (B.ID_TRAMITE_PERSONA, B.ID_PROCEDIMIENTO, B.ID_PARAMETRO, B.VALOR, B.ORDEN);

                END LOOP;


            -- INSERT REQUIREMENT PROCEDURE
            FOR PR IN (SELECT TTE.ID_TRAMITE_EVALUACION,
                              TP.ID_PROCEDIMIENTO,
                              TPP.ID_PARAMETRO,
                              DAVID.PK_PROCEDURE.FC_EXTRACT_VALUE_JSON(
                                      P_PARAMS,
                                      TPP.ID_PARAMETRO) AS VALOR,
                              TPP.ORDEN
                       FROM TR_TRAMITE_EVALUACION TTE
                                INNER JOIN DAVID.TR_REQUISITO TR ON TTE.ID_REQUISITO = TR.ID_REQUISITO
                                INNER JOIN DAVID.TR_PROCEDIMIENTO TP ON TR.ID_PROCEDIMIENTO = TP.ID_PROCEDIMIENTO
                                INNER JOIN DAVID.TR_PROCEDIMIENTO_PARAMETRO TPP
                                           ON TP.ID_PROCEDIMIENTO = TPP.ID_PROCEDIMIENTO
                       WHERE TTE.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID
                       ORDER BY TR.ID_REQUISITO, TPP.ORDEN)
                LOOP

                    MERGE INTO DAVID.TR_TRAMITE_PARAMETRO A
                    USING (SELECT P_PERSONAL_PROCEDURE_ID    AS ID_TRAMITE_PERSONA,
                                  PR.ID_TRAMITE_EVALUACION   AS ID_TRAMITE_EVALUACION,
                                  PR.ID_PROCEDIMIENTO        AS ID_PROCEDIMIENTO,
                                  PR.ID_PARAMETRO            AS ID_PARAMETRO,
                                  REPLACE(PR.VALOR, '"', '') AS VALOR,
                                  PR.ORDEN                   AS ORDEN
                           FROM DUAL) B
                    ON (A.ID_TRAMITE_PERSONA = B.ID_TRAMITE_PERSONA AND
                        -- A.ID_TRAMITE_EVALUACION = B.ID_TRAMITE_EVALUACION AND
                        A.ID_PROCEDIMIENTO = B.ID_PROCEDIMIENTO AND
                        A.ID_PARAMETRO = B.ID_PARAMETRO)
                    WHEN MATCHED THEN
                        UPDATE
                        SET A.VALOR = B.VALOR,
                            A.ORDEN = B.ORDEN
                    WHEN NOT MATCHED THEN
                        INSERT
                        (A.ID_TRAMITE_PERSONA,
                            -- A.ID_TRAMITE_EVALUACION,
                         A.ID_PROCEDIMIENTO,
                         A.ID_PARAMETRO,
                         A.VALOR,
                         A.ORDEN)
                        VALUES (B.ID_TRAMITE_PERSONA, B.ID_PROCEDIMIENTO, B.ID_PARAMETRO,
                                B.VALOR, B.ORDEN);

                END LOOP;

        END IF;
    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_INSERT_PARAM_PROCEDURE;


    PROCEDURE SP_INIT_STATE(
        P_PERSONAL_PROCEDURE_ID IN NUMBER)
    AS
        P_HAS_PROCEDURE NUMBER(1);
        P_HAS_PROCESS   NUMBER(1);
        P_STATE_ID      NUMBER(1);
    BEGIN
        IF P_PERSONAL_PROCEDURE_ID IS NOT NULL THEN

            SELECT (CASE
                        WHEN EXISTS(SELECT TTT.ID_PROCEDIMIENTO
                                    FROM DAVID.TR_TRAMITE_PERSONA TTP
                                             INNER JOIN DAVID.TR_TIPO_TRAMITE TTT ON TTP.ID_TIPO_TRAMITE = TTT.ID_TIPO_TRAMITE
                                    WHERE TTP.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID
                                      AND TTT.ID_PROCEDIMIENTO IS NOT NULL) THEN 1
                        ELSE 0 END) AS P1,
                   (CASE
                        WHEN EXISTS(SELECT TTTP.ID_TIPO_TRAMITE_PROCESO
                                    FROM DAVID.TR_TRAMITE_PERSONA TTP
                                             INNER JOIN DAVID.TR_TIPO_TRAMITE TTT ON TTP.ID_TIPO_TRAMITE = TTT.ID_TIPO_TRAMITE
                                             INNER JOIN DAVID.TR_TIPO_TRAMITE_PROCESO TTTP
                                                        ON TTT.ID_TIPO_TRAMITE = TTTP.ID_TIPO_TRAMITE
                                    WHERE TTP.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID) THEN 1
                        ELSE 0 END) AS P2
            INTO P_HAS_PROCEDURE,P_HAS_PROCESS
            FROM DUAL;

            IF P_HAS_PROCESS = 0 AND P_HAS_PROCEDURE = 1 THEN
                SELECT TE.ID_ESTADO INTO P_STATE_ID FROM DAVID.TR_ESTADO TE WHERE TE.CODIGO = 'TR_AUTO';
            ELSE
                SELECT TE.ID_ESTADO INTO P_STATE_ID FROM DAVID.TR_ESTADO TE WHERE TE.CODIGO = 'TR_APER';
            END IF;

            IF P_STATE_ID IS NOT NULL THEN
                UPDATE DAVID.TR_TRAMITE_PERSONA TTP3
                SET TTP3.ID_ESTADO = P_STATE_ID
                WHERE TTP3.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID;
            END IF;

        END IF;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END SP_INIT_STATE;

    FUNCTION
        FC_PROCEDURE_BUILD(P_PROCEDURE_ID IN NUMBER, P_PARAMS IN VARCHAR2) RETURN VARCHAR2 IS
        P_RET VARCHAR2(1000);
    BEGIN

        IF
            P_PROCEDURE_ID IS NOT NULL
        THEN
            SELECT TP.CODIGO || '(' ||
                   LISTAGG(DAVID.PK_PROCEDURE.FC_EXTRACT_VALUE_JSON(P_PARAMS, P.ID_PARAMETRO), ',')
                           WITHIN GROUP (ORDER BY TPP.ORDEN) || ',:1)'
            INTO P_RET
            FROM DAVID.TR_PROCEDIMIENTO TP
                     LEFT JOIN DAVID.TR_PROCEDIMIENTO_PARAMETRO TPP
                               ON TP.ID_PROCEDIMIENTO = TPP.ID_PROCEDIMIENTO
                     LEFT JOIN DAVID.TR_PARAMETRO P ON TPP.ID_PARAMETRO = P.ID_PARAMETRO
            WHERE TP.ID_PROCEDIMIENTO = P_PROCEDURE_ID
              AND TP.ESTADO = 1
            GROUP BY TP.CODIGO;

        END IF;

        RETURN P_RET;


    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END FC_PROCEDURE_BUILD;

    FUNCTION FC_PROCEDURE_PERCENTAGE(
        P_PERSONAL_PROCEDURE_ID IN NUMBER)
        RETURN NUMBER IS
        P_RESULT        NUMBER(10);
        P_HAS_PROCEDURE NUMBER(1);
        P_HAS_PROCESS   NUMBER(1);
    BEGIN

        IF P_PERSONAL_PROCEDURE_ID IS NOT NULL
        THEN

            SELECT (CASE
                        WHEN EXISTS(SELECT TTT.ID_PROCEDIMIENTO
                                    FROM DAVID.TR_TRAMITE_PERSONA TTP
                                             INNER JOIN DAVID.TR_TIPO_TRAMITE TTT ON TTP.ID_TIPO_TRAMITE = TTT.ID_TIPO_TRAMITE
                                    WHERE TTP.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID
                                      AND TTT.ID_PROCEDIMIENTO IS NOT NULL) THEN 1
                        ELSE 0 END) AS P1,
                   (CASE
                        WHEN EXISTS(SELECT TTTP.ID_TIPO_TRAMITE_PROCESO
                                    FROM DAVID.TR_TRAMITE_PERSONA TTP
                                             INNER JOIN DAVID.TR_TIPO_TRAMITE TTT ON TTP.ID_TIPO_TRAMITE = TTT.ID_TIPO_TRAMITE
                                             INNER JOIN DAVID.TR_TIPO_TRAMITE_PROCESO TTTP
                                                        ON TTT.ID_TIPO_TRAMITE = TTTP.ID_TIPO_TRAMITE
                                    WHERE TTP.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID) THEN 1
                        ELSE 0 END) AS P2
            INTO P_HAS_PROCEDURE,P_HAS_PROCESS
            FROM DUAL;


            IF P_HAS_PROCESS = 0 AND P_HAS_PROCEDURE = 1 THEN
                P_RESULT := 100;

            ELSIF P_HAS_PROCESS = 0 AND P_HAS_PROCEDURE = 0 THEN
                P_RESULT := 0;

            ELSIF P_HAS_PROCESS = 1 AND (P_HAS_PROCEDURE = 0 OR P_HAS_PROCEDURE = 1) THEN

                SELECT ((COUNT(CASE WHEN TTP2.ESTADO = 1 THEN 1 END) / COUNT(TTTP.ID_TIPO_TRAMITE_PROCESO)) * 100)
                INTO P_RESULT
                FROM DAVID.TR_TRAMITE_PERSONA TTP
                         INNER JOIN DAVID.TR_TIPO_TRAMITE TTT ON TTP.ID_TIPO_TRAMITE = TTT.ID_TIPO_TRAMITE
                         INNER JOIN DAVID.TR_TIPO_TRAMITE_PROCESO TTTP ON TTT.ID_TIPO_TRAMITE = TTTP.ID_TIPO_TRAMITE
                         LEFT JOIN DAVID.TR_TRAMITE_PROCESO TTP2
                                   ON TTP.ID_TRAMITE_PERSONA = TTP2.ID_TRAMITE_PERSONA and
                                      TTTP.ID_ACTIVIDAD = TTP2.ID_ACTIVIDAD
                WHERE TTP.ID_TRAMITE_PERSONA = P_PERSONAL_PROCEDURE_ID;

            ELSE
                P_RESULT := 0;
            END IF;


        END IF;

        RETURN P_RESULT;
    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END FC_PROCEDURE_PERCENTAGE;

    FUNCTION
        FC_EXTRACT_PARAMETERS(P_PROCEDURE_TYPE_ID IN NUMBER) RETURN VARCHAR2 IS
        P_RET VARCHAR2(500) := '';
    BEGIN

        SELECT LISTAGG(RET.ID_PARAMETRO, ',') WITHIN GROUP (ORDER BY RET.ORDEN)
        INTO P_RET
        FROM (SELECT P.ID_PARAMETRO, TPP.ORDEN
              FROM DAVID.TR_TIPO_TRAMITE TTT
                       INNER JOIN DAVID.TR_PROCEDIMIENTO TP ON TTT.ID_PROCEDIMIENTO = TP.ID_PROCEDIMIENTO
                       INNER JOIN DAVID.TR_PROCEDIMIENTO_PARAMETRO TPP ON TP.ID_PROCEDIMIENTO = TPP.ID_PROCEDIMIENTO
                       INNER JOIN DAVID.TR_PARAMETRO P ON TPP.ID_PARAMETRO = P.ID_PARAMETRO
              WHERE TTT.ID_TIPO_TRAMITE = P_PROCEDURE_TYPE_ID
                AND TTT.ESTADO = 1
                AND TP.ESTADO = 1
                AND TP.TIPO = 2
              UNION
              SELECT P.ID_PARAMETRO, TPP.ORDEN
              FROM DAVID.TR_TIPO_TRAMITE_REQUISITO TTTR
                       INNER JOIN DAVID.TR_REQUISITO TR ON TTTR.ID_REQUISITO = TR.ID_REQUISITO
                       INNER JOIN DAVID.TR_PROCEDIMIENTO TP ON TR.ID_PROCEDIMIENTO = TP.ID_PROCEDIMIENTO
                       INNER JOIN DAVID.TR_PROCEDIMIENTO_PARAMETRO TPP ON TP.ID_PROCEDIMIENTO = TPP.ID_PROCEDIMIENTO
                       INNER JOIN DAVID.TR_PARAMETRO P ON TPP.ID_PARAMETRO = P.ID_PARAMETRO
              WHERE TTTR.ID_TIPO_TRAMITE = P_PROCEDURE_TYPE_ID
                AND TTTR.ESTADO = 1
                AND TR.ESTADO = 1
                AND TP.ESTADO = 1
                AND TP.TIPO = 1) RET;

        RETURN P_RET;


    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END FC_EXTRACT_PARAMETERS;

    FUNCTION
        FC_EXTRACT_FILES(P_PROCEDURE_TYPE_ID IN NUMBER) RETURN VARCHAR2 IS
        P_RET VARCHAR2(1000) := '';
    BEGIN

        SELECT LISTAGG(TR.ID_REQUISITO || '|' || TR.NOMBRE, ',') WITHIN GROUP (ORDER BY TTTR.ORDEN)
        INTO P_RET
        FROM DAVID.TR_TIPO_TRAMITE_REQUISITO TTTR
                 INNER JOIN TR_REQUISITO TR
                            ON TTTR.ID_REQUISITO = TR.ID_REQUISITO
                 INNER JOIN TR_TIPO_REQUISITO TTR ON TR.ID_TIPO_REQUISITO = TTR.ID_TIPO_REQUISITO
                 INNER JOIN TR_TIPO_VALIDACION TTV ON TR.ID_TIPO_VALIDACION = TTV.ID_TIPO_VALIDACION
        WHERE TTTR.ID_TIPO_TRAMITE = P_PROCEDURE_TYPE_ID
          AND TTR.CODIGO = 'DOCUMENTATION'
          AND TTV.CODIGO = 'REQUEST'
          AND TR.ESTADO = 1
          AND TTTR.ESTADO = 1;

        RETURN P_RET;


    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END FC_EXTRACT_FILES;

    FUNCTION
        FC_EXTRACT_VALUE_JSON(P_PARAMS IN VARCHAR2, P_PARAMETER_ID IN VARCHAR2) RETURN VARCHAR2 IS
        P_RET VARCHAR2(100);
    BEGIN
        IF
            P_PARAMS IS NOT NULL
        THEN
            SELECT REGEXP_SUBSTR(
                           REPLACE(P_PARAMS, '\', ''),
                           '"' || P_PARAMETER_ID || '":(.*?)(,|\}|$)', 1, 1,
                           NULL, 1)
            INTO P_RET
            FROM DUAL;

        ELSE
            P_RET := NULL;
        END IF;

        RETURN P_RET;

    EXCEPTION
        WHEN NO_DATA_FOUND THEN
            DBMS_OUTPUT.PUT_LINE('ERROR NO_DATA_FOUND');
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);

    END FC_EXTRACT_VALUE_JSON;

    FUNCTION
        FC_STUDENT_PLAN(P_PERSON_ID IN NUMBER, P_STUDENT_PLAN_ID IN NUMBER) RETURN VARCHAR2 IS
        V_VALUE VARCHAR2(400);
    BEGIN

        IF
            P_PERSON_ID IS NOT NULL AND P_STUDENT_PLAN_ID IS NOT NULL THEN
            SELECT AP.NOMBRE || ' - ' || APE.NOMBRE || ', ' || TME.NOMBRE || ' - ' || OS.NOMBRE
            INTO V_VALUE
            FROM DAVID.ACAD_ALUMNO_PLAN AAP
                     INNER JOIN DAVID.ACAD_PLAN_PROGRAMA APP ON AAP.ID_PLAN_PROGRAMA = APP.ID_PLAN_PROGRAMA
                     INNER JOIN DAVID.ACAD_PLAN AP ON APP.ID_PLAN = AP.ID_PLAN
                     INNER JOIN DAVID.ACAD_PROGRAMA_ESTUDIO APE ON APP.ID_PROGRAMA_ESTUDIO = APE.ID_PROGRAMA_ESTUDIO
                     LEFT JOIN DAVID.TIPO_MODALIDAD_ESTUDIO TME ON APE.ID_MODALIDAD_ESTUDIO = TME.ID_MODALIDAD_ESTUDIO
                     INNER JOIN ELISEO.ORG_SEDE_AREA OSA ON APE.ID_SEDEAREA = OSA.ID_SEDEAREA
                     INNER JOIN ELISEO.ORG_SEDE OS ON OSA.ID_SEDE = OS.ID_SEDE
            WHERE AAP.ID_PERSONA = P_PERSON_ID
              AND AAP.ID_ALUMNO_PLAN = P_STUDENT_PLAN_ID;
        END IF;
        RETURN V_VALUE;

    EXCEPTION
        WHEN NO_DATA_FOUND
            THEN
                DBMS_OUTPUT.PUT_LINE(SQLERRM);
                RETURN NULL;
    END FC_STUDENT_PLAN;


    FUNCTION FC_HAS_STORED_PROCEDURE(
        P_PROCEDURE_TYPE_ID IN NUMBER) RETURN NUMBER IS
        P_RET NUMBER(1) := 0;
    BEGIN
        IF P_PROCEDURE_TYPE_ID IS NOT NULL
        THEN
            SELECT (CASE
                        WHEN EXISTS(SELECT TTT.ID_PROCEDIMIENTO
                                    FROM DAVID.TR_TIPO_TRAMITE TTT
                                             LEFT JOIN DAVID.TR_PROCEDIMIENTO TP ON TTT.ID_PROCEDIMIENTO = TP.ID_PROCEDIMIENTO
                                    WHERE TTT.ID_TIPO_TRAMITE = P_PROCEDURE_TYPE_ID
                                      AND TP.CODIGO IS NOT NULL
                                      AND TP.RENDER IS NOT NULL
                                      AND TP.ESTADO = 1
                                      AND TP.TIPO = 2) THEN 1
                        ELSE 0 END)
            INTO P_RET
            FROM DUAL;

        END IF;

        RETURN P_RET;

    EXCEPTION
        WHEN OTHERS THEN
            DBMS_OUTPUT.PUT_LINE('ERROR: ' || SQLERRM);
    END FC_HAS_STORED_PROCEDURE;


END PK_PROCEDURE;