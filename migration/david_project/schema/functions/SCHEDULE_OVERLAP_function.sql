-- Generated by Ora2Pg, the Oracle database Schema converter, version 25.0
-- Copyright 2000-2025 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=10.174.11.5;sid=upeu;port=1521

SET client_encoding TO 'UTF8';

SET search_path = david,public;
\set ON_ERROR_STOP ON





CREATE OR REPLACE FUNCTION david.schedule_overlap ( P_START_DATE_FROM text, P_END_DATE_FROM text, P_DAYS_FROM text, P_START_DATE_TO text, P_END_DATE_TO text, P_DAYS_TO text) RETURNS bigint AS $body$
DECLARE

    -- Valida sobreposición entre fechas dias y horas, retorna 1 cuando tiene sobreposición de lo contrario 0
    -- Consultas a Edwin Calsin Quinto edwincqu@gmail.com, edwin_calsin@upeu.edu.pe
    -- FORMATO YYYY-MM-DD HH24:MI:SS
    /*
    SELECT DAVID.SCHEDULE_OVERLAP(
               '2023-01-01 15:30',
               '2023-02-17 16:15',
               '1,5',
               '2023-02-17 16:00',
               '2023-02-20 18:00',
               '5,6') AS RET
            FROM DUAL;
    */
    RESULT              bigint       := 0;
    VALID_PERIOD        bigint       := 0;
    VALID_TIME          bigint       := 0;
    FORMAT_TIMESTAMP    varchar(21) := 'YYYY-MM-DD HH24:MI';
    FORMAT_DATE         varchar(10) := 'YYYY-MM-DD';
    FORMAT_TIME         varchar(10) := 'HH24:MI';
    P_PERIOD_START_FROM timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_START_DATE_FROM, FORMAT_TIMESTAMP), FORMAT_DATE),
                                                FORMAT_DATE);
    P_PERIOD_END_FROM   timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_END_DATE_FROM, FORMAT_TIMESTAMP), FORMAT_DATE),
                                                FORMAT_DATE);
    P_PERIOD_START_TO   timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_START_DATE_TO, FORMAT_TIMESTAMP), FORMAT_DATE),
                                                FORMAT_DATE);
    P_PERIOD_END_TO     timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_END_DATE_TO, FORMAT_TIMESTAMP), FORMAT_DATE),
                                                FORMAT_DATE);
    P_TIME_START_FROM   timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_START_DATE_FROM, FORMAT_TIMESTAMP), FORMAT_TIME),
                                                FORMAT_TIME);
    P_TIME_END_FROM     timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_END_DATE_FROM, FORMAT_TIMESTAMP), FORMAT_TIME),
                                                FORMAT_TIME);
    P_TIME_START_TO     timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_START_DATE_TO, FORMAT_TIMESTAMP), FORMAT_TIME),
                                                FORMAT_TIME);
    P_TIME_END_TO       timestamp(0)         := TO_DATE(TO_CHAR(TO_DATE(P_END_DATE_TO, FORMAT_TIMESTAMP), FORMAT_TIME),
                                                FORMAT_TIME);



BEGIN
    IF (P_START_DATE_FROM IS NOT NULL AND P_START_DATE_FROM::text <> '') AND
       (P_END_DATE_FROM IS NOT NULL AND P_END_DATE_FROM::text <> '') AND
       (P_DAYS_FROM IS NOT NULL AND P_DAYS_FROM::text <> '') AND
       (P_START_DATE_TO IS NOT NULL AND P_START_DATE_TO::text <> '') AND
       (P_END_DATE_TO IS NOT NULL AND P_END_DATE_TO::text <> '') AND
       (P_DAYS_TO IS NOT NULL AND P_DAYS_TO::text <> '')
    THEN

        -- verify period
        SELECT COUNT(PERIOD.DUMMY)
        INTO STRICT VALID_PERIOD
         PERIOD
        where (P_PERIOD_START_FROM,
               P_PERIOD_END_FROM + INTERVAL '1' DAY) overlaps(P_PERIOD_START_TO,
               P_PERIOD_END_TO);

        IF VALID_PERIOD > 0
        THEN

            -- verify equals days
            IF regexp_match(trim(both P_DAYS_FROM), '[' || trim(both REPLACE(P_DAYS_TO, ',', '')) || ']','n') IS NOT NULL
            THEN

                -- verify hours
                SELECT COUNT(TIME.DUMMY)
                INTO STRICT VALID_TIME
                 TIME
                WHERE (P_TIME_START_FROM,
                       P_TIME_END_FROM + INTERVAL '1' MINUTE) OVERLAPS(P_TIME_START_TO,
                       P_TIME_END_TO);
                IF VALID_TIME > 0
                THEN
                    RESULT := 1;
                END IF;
            END IF;


        END IF;

    END IF;

    RETURN RESULT;
END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
 STABLE;
-- REVOKE ALL ON FUNCTION david.schedule_overlap ( P_START_DATE_FROM text, P_END_DATE_FROM text, P_DAYS_FROM text, P_START_DATE_TO text, P_END_DATE_TO text, P_DAYS_TO text) FROM PUBLIC;

