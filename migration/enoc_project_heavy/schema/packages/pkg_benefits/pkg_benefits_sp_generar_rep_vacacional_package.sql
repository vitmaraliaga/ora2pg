-- Generated by Ora2Pg, the Oracle database Schema converter, version 25.0
-- Copyright 2000-2025 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=10.174.11.5;sid=upeu;port=1521

SET client_encoding TO 'UTF8';
SET search_path = enoc,pkg_benefits,public;




CREATE OR REPLACE PROCEDURE enoc.pkg_benefits_sp_generar_rep_vacacional (P_ID_ROL_VACACION_REP text,P_ID_ROL_VACACION text, P_FECHA_INI text,P_FECHA_FIN text,P_MOTIVO_REPRO text, P_OPC text,P_ID_USER_REG bigint,P_GTH text,P_ERROR OUT bigint,P_MSGERROR out text) AS $body$
DECLARE

        l_fecha_ini timestamp(0);
        l_fecha_ini_rep timestamp(0);
        l_fecha_fin timestamp(0);
        l_contar integer;
        l_dias integer;
        l_rdias integer:=0;
        l_trdias integer:=0;
        l_id_periodo_vac_trab varchar(30);
        l_id_rol_vacacion varchar(30);
        l_error bigint:=0;
        l_msgerror varchar(200):='';
        l_minp1 bigint:=0;
        l_minp2 bigint:=0;
        l_contar1 integer;
        l_contar2 integer;
        l_opc varchar(2);
        l_total_dias integer:=0;
        l_id_periodo_vac integer;

        l_1 bigint;
        l_2 bigint;
        l_3 bigint;
        l_4 bigint;
        l_5 bigint;
        l_x bigint:=1;
        l_esta bigint:=0;
        l_dias_efec bigint:=0;
        l_motivo_repro varchar(200);

        l_id_tipo_rol_vac varchar(2);

         PP_ID_ROL_VACACION text:=P_ID_ROL_VACACION||'*';
         PP_FECHA_INI  text:=P_FECHA_INI ||'*';
         PP_FECHA_FIN text:=P_FECHA_FIN||'*';
         PP_OPC text:=P_OPC||'*';
         PP_MOTIVO_REPRO text:=P_MOTIVO_REPRO||'*';

        
BEGIN
        
          select  ID_PERIODO_VAC_TRAB,(FECHA_fin -  FECHA_INI)+1,FECHA_INI,coalesce(DIAS_EFECT,0) into STRICT  l_id_periodo_vac_trab,l_dias,l_fecha_ini_rep,l_dias_efec from PLLA_ROL_VACACIONAL where ID_ROL_VACACION=P_ID_ROL_VACACION_REP;

          if CURRENT_DATE > (l_fecha_ini_rep +1) then
              l_error:=1;
              l_msgerror:='No se puede reprogramar, la fecha actual es mayor a fecha inicio';
          else
            if l_dias_efec>0 then
              l_error:=1;
              l_msgerror:='Ya se ha generado días afectivas';
            end if;
          end if;

          if l_error=0 then
          
            select ID_PERIODO_VAC  into STRICT l_id_periodo_vac 
            from PLLA_PERIODO_VAC_TRAB where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab;

            select MIN_DIAS_PERIODO1, MIN_DIAS_PERIODO2 into STRICT l_minp1, l_minp2 from PLLA_PERIODO_VAC where ID_PERIODO_VAC= l_id_periodo_vac;

            
            
            loop
              l_1 := position('*'  in PP_ID_ROL_VACACION);
              l_2 := position('*'  in PP_FECHA_INI);
              l_3 := position('*' in PP_FECHA_FIN);
              exit when coalesce(l_1,0) = 0;

              
                  select cast(substr(PP_FECHA_INI,1, l_2-1) as timestamp(0)),cast(substr(PP_FECHA_FIN,1, l_3-1) as timestamp(0)) into STRICT l_fecha_ini, l_fecha_fin;

                  select
                  case when l_fecha_ini<PERIODO_INI then 1 else 0 end,
                  case when l_fecha_fin>PERIODO_FIN then 1 else 0 end
                  into STRICT l_contar1,l_contar2
                  from PLLA_PERIODO_VAC_TRAB where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab;

                  if l_contar1>0 then
                      l_error:=1;
                      l_msgerror:='Fecha inicio no debe ser menor a la fecha inicial del periodo del trabjador';
                      Exit when l_contar1>0;
                  else
                    if l_contar2>0 then
                        l_error:=1;
                        l_msgerror:='Fecha fin no debe ser mayor a la fecha final del periodo del trabjador';
                        Exit when l_contar2>0;
                    end if;
                  end if;
                  select (l_fecha_fin -  l_fecha_ini)+1 into STRICT l_rdias;
                  if P_GTH='S' then
                    l_minp1:=1;
                  end if;
                  if l_rdias<l_minp1 then
                      l_error:=1;
                      l_msgerror:='En el periodo  se debe registrar como mínimo '||l_minp1::text||' días';
                      Exit when l_rdias<l_minp1;
                  end if;

                  select count(*) into STRICT  l_contar1 from PLLA_ROL_VACACIONAL 
                  where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab
                  and (to_date(TO_CHAR(l_fecha_ini, 'MM/DD/YYYY'),'MM/DD/YYYY') between FECHA_INI and FECHA_fin)
                  and ID_ROL_VACACION not in (trim(both substr(PP_ID_ROL_VACACION,1, l_1-1)),P_ID_ROL_VACACION_REP);

                  if l_contar1>0 then
                      l_error:=1;
                      l_msgerror:='Fecha inicio debe inciar despues de la fecha termino del registro anterior';
                      Exit when l_contar1>0;
                  end if;

                        
                  if CURRENT_DATE> (l_fecha_ini +1) then
                      l_error:=1;
                      l_msgerror:='Fecha inicio  debe ser mayor a fecha actual';
                      Exit when l_fecha_ini>CURRENT_DATE;
                  end if;

                  l_trdias:=l_trdias + l_rdias;

                  PP_ID_ROL_VACACION := substr(PP_ID_ROL_VACACION, l_1+1 );
                  PP_FECHA_INI := substr(PP_FECHA_INI, l_2+1 );
                  PP_FECHA_FIN := substr(PP_FECHA_FIN, l_3+1 );

     
              END LOOP;
          end if;

          if l_error=0 then
            if l_trdias<>l_dias then
              l_error:=1;
              l_msgerror:='Total días son diferentes entre programado y reprogramado';
            end if;
          end if;
          PP_ID_ROL_VACACION :=P_ID_ROL_VACACION||'*';
          PP_FECHA_INI  :=P_FECHA_INI||'*';
          PP_FECHA_FIN :=P_FECHA_FIN||'*';
          PP_MOTIVO_REPRO :=P_MOTIVO_REPRO||'*';

          if l_error=0 then
          
              delete from PLLA_ROL_VACACIONAL where ID_PARENT = P_ID_ROL_VACACION_REP;

              select ID_TIPO_ROL_VAC into STRICT l_id_tipo_rol_vac from PLLA_ROL_VACACIONAL where ID_ROL_VACACION=P_ID_ROL_VACACION_REP;

              LOOP
                l_1 := position('*'  in PP_ID_ROL_VACACION);
                l_2 := position('*'  in PP_FECHA_INI);
                l_3 := position('*' in PP_FECHA_FIN);
                l_4 := position('*' in PP_OPC);
                l_4 := position('*' in PP_OPC);
                l_5 := position('*' in PP_MOTIVO_REPRO);
                exit when coalesce(l_1,0) = 0;
                l_opc := 'I';--trim(substr(PP_OPC,1, l_4-1)); 
                select cast(substr(PP_FECHA_INI,1, l_2-1) as timestamp(0)),cast(substr(PP_FECHA_FIN,1, l_3-1) as timestamp(0)),substr(PP_MOTIVO_REPRO,1, l_5-1) into STRICT l_fecha_ini, l_fecha_fin,l_motivo_repro;
                if (l_fecha_ini IS NOT NULL AND l_fecha_ini::text <> '') then
                  if l_opc='I' then
                    l_id_rol_vacacion:= TO_CHAR(clock_timestamp(), 'YYYYMMDDHH24MISS')||l_x::text;

                    
                    insert into PLLA_ROL_VACACIONAL(
                      ID_ROL_VACACION,
                      ID_PERIODO_VAC_TRAB,
                      FECHA_INI,
                      FECHA_FIN,
                      DIAS,
                      DIAS_EFECT,
                      CONDICION,
                      ID_ESTADO_ROL_VAC,
                      FECHA_REGISTRA,
                      ID_USER_REG,
                      ID_PARENT,
                      MOTIVO_REPRO,
                      ID_TIPO_ROL_VAC
                    )values(
                      l_id_rol_vacacion,
                      l_id_periodo_vac_trab,
                      l_fecha_ini,
                      l_fecha_fin,
                      (l_fecha_fin -  l_fecha_ini)+1,
                      0,
                      'P',
                      '01',
                      clock_timestamp(),
                      P_ID_USER_REG,
                      P_ID_ROL_VACACION_REP,
                      l_motivo_repro,
                      l_id_tipo_rol_vac
                    );
                    l_x:=l_x + 1;
                  else
                    update PLLA_ROL_VACACIONAL set
                    FECHA_INI=l_fecha_ini,
                    FECHA_FIN=l_fecha_fin,
                    DIAS = (l_fecha_fin -  l_fecha_ini)+1,
                    MOTIVO_REPRO=l_motivo_repro,
                    FECHA_REGISTRA=clock_timestamp(),
                    ID_USER_REG=P_ID_USER_REG
                    where ID_ROL_VACACION=trim(both substr(PP_ID_ROL_VACACION,1, l_1-1));

                  end if;
                  l_esta:= l_esta + 1;
                 end if;
                 PP_ID_ROL_VACACION := substr(PP_ID_ROL_VACACION, l_1+1 );
                 PP_FECHA_INI := substr(PP_FECHA_INI, l_2+1 );
                 PP_FECHA_FIN := substr(PP_FECHA_FIN, l_3+1 );
                 PP_OPC := substr(PP_OPC, l_4+1 );
                 PP_MOTIVO_REPRO := substr(PP_MOTIVO_REPRO, l_5+1 );
                 
              END LOOP;

              if l_esta>0 then
                update PLLA_ROL_VACACIONAL set
                CONDICION='R'
                where ID_ROL_VACACION=P_ID_ROL_VACACION_REP;
              else
                update PLLA_ROL_VACACIONAL set
                CONDICION='P'
                where ID_ROL_VACACION=P_ID_ROL_VACACION_REP;
              end if;

              select coalesce(sum((FECHA_fin -  FECHA_INI)+1),0) into STRICT  l_total_dias  from PLLA_ROL_VACACIONAL 
              where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab
              and CONDICION = 'P';

              update PLLA_PERIODO_VAC_TRAB set
              total_dias=l_total_dias
              where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab;

          end if;
          
          P_ERROR:=l_error;
          P_MSGERROR:= l_msgerror;

        END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE enoc.pkg_benefits_sp_generar_rep_vacacional (P_ID_ROL_VACACION_REP text,P_ID_ROL_VACACION text, P_FECHA_INI text,P_FECHA_FIN text,P_MOTIVO_REPRO text, P_OPC text,P_ID_USER_REG bigint,P_GTH text,P_ERROR OUT bigint,P_MSGERROR out text) FROM PUBLIC;
