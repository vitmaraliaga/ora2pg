-- Generated by Ora2Pg, the Oracle database Schema converter, version 25.0
-- Copyright 2000-2025 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=10.174.11.5;sid=upeu;port=1521

SET client_encoding TO 'UTF8';
SET search_path = enoc,pkg_benefits,public;




CREATE OR REPLACE PROCEDURE enoc.pkg_benefits_sp_generar_rol_vacacional_upn (P_ID_ROL_VACACION text,P_ID_PARENT text, P_ID_PERIODO_VAC_TRAB text,P_FECHA_INI timestamp(0),P_FECHA_FIN timestamp(0),P_OPC text,P_ID_USER_REG bigint,P_ERROR OUT bigint,P_MSGERROR out text) AS $body$
DECLARE

        l_id_rol_vacacion varchar(30);
        l_error bigint:=0;
        l_msgerror varchar(200):='';
        l_total_dias bigint:=0;
        l_dias_anho bigint:=0;
        l_dias bigint:=0;
        l_id_periodo_vac bigint;
        l_id_trabajador bigint;
        l_minp1 bigint:=0;
        l_minp2 bigint:=0;
        l_contar1 bigint:=0;
        l_contar2 bigint:=0;
        l_diasqueda bigint:=0;
        l_id_tipo_suspension bigint;
       	l_id_parent varchar(25);

       	l_es_interno bigint:=0;
		l_id_tipo_rol_vac varchar(2):='R';

        
BEGIN
	        
	     l_id_parent := P_ID_PARENT;
	     IF P_ID_PARENT = '' THEN
	     	l_id_parent := NULL;
	     END IF;

         if P_OPC='D' THEN
        	SELECT ID_PARENT INTO STRICT l_id_parent FROM ENOC.PLLA_ROL_VACACIONAL WHERE ID_ROL_VACACION=P_ID_ROL_VACACION;
        	SELECT COUNT(*) INTO STRICT l_contar1 FROM ENOC.PLLA_ROL_VACACIONAL WHERE ID_PARENT = l_id_parent;

         	IF (l_id_parent IS NOT NULL AND l_id_parent::text <> '') AND l_contar1 = 1 THEN
         		l_error:=1;
                l_msgerror:='No se puede eliminar, porque existe una reprogramación que se debe completar.';
--                 GOTO salida_rol_vac;
         	END IF;

         	delete from ENOC.PLLA_ROL_VACACIONAL_HIST where ID_ROL_VACACION=P_ID_ROL_VACACION;
          	delete from ENOC.PLLA_ROL_VACACIONAL where ID_ROL_VACACION=P_ID_ROL_VACACION;

         else
           if P_FECHA_FIN<P_FECHA_INI then
                l_error:=1;
                l_msgerror:='Fecha fin no debe ser menor a la fecha inicio';
--                 GOTO salida_rol_vac;
           end if;

            select (P_FECHA_FIN -  P_FECHA_INI)+1 into STRICT l_dias;

            select ID_PERIODO_VAC ,
            case when P_FECHA_INI<PERIODO_INI then 1 else 0 end,
            case when P_FECHA_FIN>PERIODO_FIN then 1 else 0 END,
            dias_anho,
            id_trabajador,
            es_interno
            into STRICT l_id_periodo_vac ,l_contar1,l_contar2,l_dias_anho,l_id_trabajador,l_es_interno
            from PLLA_PERIODO_VAC_TRAB where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB;

            if l_error=0 then
              if l_contar1>0 then
                  l_error:=1;
                  l_msgerror:='Fecha inicio no debe ser menor a la fecha inicial del periodo del trabajador';
--                   GOTO salida_rol_vac;
              else
                if l_contar2>0 then
                    l_error:=1;
                    l_msgerror:='Fecha fin no debe ser mayor a la fecha final del periodo del trabajador';
--                     GOTO salida_rol_vac;
                end if;
              end if;
            end if;

            if l_error=0 then
              select count(*) into STRICT  l_contar1 from PLLA_ROL_VACACIONAL 
              where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB
              and (to_date(TO_CHAR(P_FECHA_INI, 'MM/DD/YYYY'),'MM/DD/YYYY') between FECHA_INI and FECHA_FIN)
              and condicion='P'
              and ID_ROL_VACACION<>P_ID_ROL_VACACION;

              if l_contar1>0 then
                  l_error:=1;
                  l_msgerror:='Hay cruce con la fecha de inicio';
--                   GOTO salida_rol_vac;
              end if;

              select count(*) into STRICT  l_contar1 from PLLA_ROL_VACACIONAL 
              where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB
              and (to_date(TO_CHAR(P_FECHA_FIN, 'MM/DD/YYYY'),'MM/DD/YYYY') between FECHA_INI and FECHA_FIN)
              and condicion='P'
              and ID_ROL_VACACION<>P_ID_ROL_VACACION;

              if l_contar1>0 then
                  l_error:=1;
                  l_msgerror:='Hay cruce con la fecha fin';
--                   GOTO salida_rol_vac;
              end if;

            end if;

            if l_error=0 then
              select MIN_DIAS_PERIODO1, MIN_DIAS_PERIODO2 into STRICT l_minp1, l_minp2 from PLLA_PERIODO_VAC where ID_PERIODO_VAC= l_id_periodo_vac;

              select coalesce(sum((FECHA_fin -  FECHA_INI)+1),0) into STRICT  l_total_dias  from PLLA_ROL_VACACIONAL 
              where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB and condicion='P'
              and ID_ROL_VACACION<>P_ID_ROL_VACACION;

             --Contamos cuantos registros ya existen
             select count(*) into STRICT l_contar1 from PLLA_ROL_VACACIONAL 
	              where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB
	              and condicion='P'
	              and ID_ROL_VACACION<>P_ID_ROL_VACACION;
	
              if l_total_dias>23 then
                l_diasqueda:= 30 - l_total_dias;
                if l_diasqueda<>l_dias then
                    l_error:=1;
                    l_msgerror:='Se debe registra los dias restantes ('||l_diasqueda::text||') días';
--                     GOTO salida_rol_vac;
                end if;
              else

                if l_dias<l_minp1 AND l_dias_anho >= l_minp1 AND l_contar1= 0 then
                    l_error:=1;
                    l_msgerror:='En el periodo se debe registrar como mínimo '||l_minp1::text||' días';
--                     GOTO salida_rol_vac;
                end if;
              end if;

             --Validar si el periodo inicial es mayor a 7 dias, entonces debe registrarse como minimo un sabado y un domingo
             
             IF l_minp1 >=7 AND l_dias_anho >= l_minp1 AND l_contar1 = 0 THEN 
             	SELECT COUNT(*) INTO STRICT l_contar1
				FROM (WITH RECURSIVE cte AS (

				  SELECT P_FECHA_INI + LEVEL - 1 AS days
				  
				  LEVEL <= P_FECHA_FIN - P_FECHA_INI + 1
				  UNION ALL

				  SELECT P_FECHA_INI + LEVEL - 1 AS days
				  
				  LEVEL <= P_FECHA_FIN - P_FECHA_INI + 1
				 JOIN cte c ON ()

) SELECT * FROM cte) alias1
				WHERE TO_CHAR(days,'D','NLS_DATE_LANGUAGE=ENGLISH') IN (7, 1);
				IF l_contar1 < 2 THEN
					l_error:=1;
                    l_msgerror:='En el periodo inicial se debe registrar como mínimo un sábado y un domingo';
--                     GOTO salida_rol_vac;
				end IF;
             END IF;

            IF l_total_dias + l_dias = l_dias_anho THEN 
				-- Calcular el número total de sábados
				SELECT COALESCE(sum(T.TOTAL),0) into STRICT l_contar1 FROM (SELECT 
				    TRUNC((FECHA_FIN - NEXT_DAY(FECHA_INI - 1, 7)) / 7) + 
				    CASE 
					WHEN NEXT_DAY(FECHA_INI - 1, 7) <= FECHA_FIN THEN 1 ELSE 0 END  AS TOTAL
				FROM PLLA_ROL_VACACIONAL
				where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB and condicion='P'
				and ID_ROL_VACACION<>P_ID_ROL_VACACION)T;
			
				SELECT l_contar1 + COUNT(*) INTO STRICT l_contar1
				FROM (WITH RECURSIVE cte AS (

				  SELECT P_FECHA_INI + LEVEL - 1 AS days
				  
				  LEVEL <= P_FECHA_FIN - P_FECHA_INI + 1
				  UNION ALL

				  SELECT P_FECHA_INI + LEVEL - 1 AS days
				  
				  LEVEL <= P_FECHA_FIN - P_FECHA_INI + 1
				 JOIN cte c ON ()

) SELECT * FROM cte) alias1
				WHERE TO_CHAR(days,'D','NLS_DATE_LANGUAGE=ENGLISH') IN (7);
				IF l_contar1 < 4 AND l_dias_anho > 6 THEN
					l_error:=1;
				    l_msgerror:='Dentro de los 30 dias programados debe incluir como mímino 4 sábados y 4 domingos';
-- 				    GOTO salida_rol_vac;
				end IF;
				IF l_contar1 < 1 AND l_dias_anho <= 6 THEN 
					l_error:=1;
				    l_msgerror:='Dentro de los 6 dias programados debe incluir como mímino 1 sábados y 1 domingos';
-- 				    GOTO salida_rol_vac;
				end IF;
				-- Calcular el número total de domingos
				SELECT COALESCE(sum(T.TOTAL),0) into STRICT l_contar1 FROM (SELECT
				TRUNC((FECHA_FIN - NEXT_DAY(FECHA_INI - 1, 1)) / 7) + 
				CASE 
				    WHEN NEXT_DAY(FECHA_INI - 1, 1) <= FECHA_FIN THEN 1 ELSE 0 END AS TOTAL
				FROM PLLA_ROL_VACACIONAL
				where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB and condicion='P'
				and ID_ROL_VACACION<>P_ID_ROL_VACACION)T;
			
				SELECT l_contar1 + COUNT(*) INTO STRICT l_contar1
				FROM (WITH RECURSIVE cte AS (

				  SELECT P_FECHA_INI + LEVEL - 1 AS days
				  
				  LEVEL <= P_FECHA_FIN - P_FECHA_INI + 1
				  UNION ALL

				  SELECT P_FECHA_INI + LEVEL - 1 AS days
				  
				  LEVEL <= P_FECHA_FIN - P_FECHA_INI + 1
				 JOIN cte c ON ()

) SELECT * FROM cte) alias1
				WHERE TO_CHAR(days,'D','NLS_DATE_LANGUAGE=ENGLISH') IN (1);
				IF l_contar1 < 4 AND l_dias_anho > 6 THEN
					l_error:=1;
				    l_msgerror:='Dentro de los 30 dias programados debe incluir como mímino 4 sábados y 4 domingos';
-- 			        GOTO salida_rol_vac;
				end IF;
				IF l_contar1 < 1 AND l_dias_anho <= 6 THEN
					l_error:=1;
				    l_msgerror:='Dentro de los 6 dias programados debe incluir como mímino 1 sábados y 1 domingos';
-- 			        GOTO salida_rol_vac;
				end IF;
			END IF;

              /*if l_total_dias>0 and l_total_dias<15 then
                if l_dias<l_minp1 then
                  l_error:=1;
                  l_msgerror:='En el periodo 1 se debe registrar como mínimo '||to_char(l_minp1)||' días';
                else
                  if (l_total_dias+l_dias)>15 then
                    l_error:=1;
                    l_msgerror:='En el periodo 1 se debe registrar como mínimo '||to_char(l_minp1)||' días';
                  end if;
                end if;
              else
                if l_total_dias = 0 then
                  if l_dias<l_minp1 then
                    l_error:=1;
                    l_msgerror:='En el periodo 1 se debe registrar como mínimo '||to_char(l_minp1)||' días';
                  
                  end if;
                else
                  if l_dias<l_minp2 then
                    l_error:=1;
                    l_msgerror:='En el periodo 2 se debe registrar como mínimo '||to_char(l_minp2)||' días';
                  end if;
                end if;
              end if;*/
            end if;

            if l_error=0 then
              if (l_total_dias+l_dias)>30 then
                  l_error:=1;
                  l_msgerror:='Total dias no debe exceder 30 días, actual: '||l_total_dias+l_dias::text;
--                   GOTO salida_rol_vac;
              end if;
            end if;

           	--Validar si no existen permisos dentro de un tramo de vacaciones
           	select count(*) into STRICT l_contar1 from ENOC.PLLA_LICENCIA_PERMISO plp  
            where ID_TRABAJADOR = l_id_trabajador
            AND ID_ESTADO_LICA_PER = '03'
            AND ((P_FECHA_INI >=FECHA_DESDE AND P_FECHA_INI <=FECHA_HASTA)
           	OR (P_FECHA_FIN >=FECHA_DESDE AND P_FECHA_FIN <=FECHA_HASTA));

           	IF l_contar1 > 0 THEN 
           		l_error:=1;
	            l_msgerror:='Existe un(a) permiso/licencia aprobado que hace un cruce con este periodo.';
-- 	            GOTO salida_rol_vac;
           	END IF;

            if l_error=0 then
            
              select id_tipo_suspension into STRICT l_id_tipo_suspension from plla_tipo_suspension where codsunat='23';

              if P_OPC='I' then
              
                l_id_rol_vacacion:= TO_CHAR(clock_timestamp(), 'YYYYMMDDHH24MISS') || LPAD(nextval('enoc.plla_rol_vacacional_item_pk')::text, 6, '0');

               IF l_es_interno = 1 THEN 
               	l_id_tipo_rol_vac :='I';
               END IF;
               insert into PLLA_ROL_VACACIONAL(
                  ID_ROL_VACACION,
                  ID_PERIODO_VAC_TRAB,
                  FECHA_INI,
                  FECHA_FIN,
                  DIAS,
                  DIAS_EFECT,
                  CONDICION,
                  ID_ESTADO_ROL_VAC,
                  FECHA_REGISTRA,
                  ID_USER_REG,
                  ID_TIPO_SUSPENSION,
                  ID_TIPO_ROL_VAC,
                  ID_PARENT
                )values(
                  l_id_rol_vacacion,
                  P_ID_PERIODO_VAC_TRAB,
                  P_FECHA_INI,
                  P_FECHA_FIN,
                  (P_FECHA_FIN -  P_FECHA_INI)+1,
                  0,
                  'P',
                  '01',
                  clock_timestamp(),
                  P_ID_USER_REG,
                  l_id_tipo_suspension,
                  l_id_tipo_rol_vac,
                  l_id_parent
                );
              else
                update PLLA_ROL_VACACIONAL set
                FECHA_INI=P_FECHA_INI,
                FECHA_FIN=P_FECHA_FIN,
                DIAS = (P_FECHA_FIN -  P_FECHA_INI)+1,
                FECHA_REGISTRA=clock_timestamp(),
                ID_USER_REG=P_ID_USER_REG
                where ID_ROL_VACACION=P_ID_ROL_VACACION;

                l_id_rol_vacacion:=P_ID_ROL_VACACION;

              end if;

            --Agregamos en la tabla historial
         	BEGIN
              CALL enoc.pkg_benefits_sp_generar_rol_vacacional_hist(P_ID_PERIODO_VAC_TRAB,l_error,l_msgerror);
            END;
              
          end if;
        end if;
         select coalesce(sum((FECHA_fin -  FECHA_INI)+1),0) into STRICT  l_total_dias  from PLLA_ROL_VACACIONAL
          where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB and condicion='P';

          update PLLA_PERIODO_VAC_TRAB set
          total_dias=l_total_dias
          where ID_PERIODO_VAC_TRAB=P_ID_PERIODO_VAC_TRAB;

--         <<salida_rol_vac>> 
        P_ERROR:=l_error;
        P_MSGERROR:= l_msgerror;
        END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE enoc.pkg_benefits_sp_generar_rol_vacacional_upn (P_ID_ROL_VACACION text,P_ID_PARENT text, P_ID_PERIODO_VAC_TRAB text,P_FECHA_INI timestamp(0),P_FECHA_FIN timestamp(0),P_OPC text,P_ID_USER_REG bigint,P_ERROR OUT bigint,P_MSGERROR out text) FROM PUBLIC;
