-- Generated by Ora2Pg, the Oracle database Schema converter, version 25.0
-- Copyright 2000-2025 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:host=10.174.11.5;sid=upeu;port=1521

SET client_encoding TO 'UTF8';
SET search_path = enoc,pkg_benefits,public;




CREATE OR REPLACE PROCEDURE enoc.pkg_benefits_sp_generar_vac_adelanto (P_ID_PERIODO_VAC bigint, P_ID_SOL_VAC_ADEL_DET bigint,P_ID_TRABAJADOR bigint,P_FECHA_INI timestamp(0),P_FECHA_FIN timestamp(0),P_ID_USER_REG bigint,P_ITEM bigint,P_ERROR OUT bigint,P_MSGERROR out text) AS $body$
DECLARE

        l_id_rol_vacacion varchar(30);
        l_error bigint:=0;
        l_msgerror varchar(200):='';
        l_total_dias bigint:=0;
        l_dias bigint:=0;
        l_id_periodo_vac bigint;
        l_minp1 bigint:=0;
        l_minp2 bigint:=0;
        l_contar1 bigint:=0;
        l_contar2 bigint:=0;
        l_diasqueda bigint:=0;
        l_id_tipo_suspension bigint;

        l_id_periodo_vac_trab varchar(25);
        l_dias_anho bigint:=0;

BEGIN

           if P_FECHA_FIN<P_FECHA_INI then
                l_error:=1;
                l_msgerror:='Fecha fin no debe ser menor a la fecha inicio';
--                 GOTO salida_gen_vac_ade;
           end if;

            select (P_FECHA_FIN -  P_FECHA_INI)+1 into STRICT l_dias;

            CALL pkg_benefits_sp_gen_periodo_vac_trab_adel(P_ID_TRABAJADOR, P_ID_PERIODO_VAC,1,l_id_periodo_vac_trab, l_error,l_msgerror);

            IF l_error<>0 THEN
--               GOTO salida_gen_vac_ade;
            END IF;

            select count(*) into STRICT  l_contar1 from ENOC.VW_ROL_VACACIONAL 
            where ID_TRABAJADOR = P_ID_TRABAJADOR
            and (to_date(TO_CHAR(P_FECHA_INI, 'MM/DD/YYYY'),'MM/DD/YYYY') between FECHA_INI and FECHA_FIN)
            and condicion='P';

            if l_contar1>0 then
                l_error:=1;
                l_msgerror:='Hay cruce con la fecha de inicio';
--                 GOTO salida_gen_vac_ade;
            end if;

            
            select count(*) into STRICT  l_contar1 from ENOC.VW_ROL_VACACIONAL 
            where ID_TRABAJADOR = P_ID_TRABAJADOR
            and (to_date(TO_CHAR(P_FECHA_FIN, 'MM/DD/YYYY'),'MM/DD/YYYY') between FECHA_INI and FECHA_FIN)
            and condicion='P';

            if l_contar1>0 then
                l_error:=1;
                l_msgerror:='Hay cruce con la fecha fin';
--                 GOTO salida_gen_vac_ade;
            end if;


            select MIN_DIAS_PERIODO1, MIN_DIAS_PERIODO2 into STRICT l_minp1, l_minp2 from PLLA_PERIODO_VAC where ID_PERIODO_VAC= P_ID_PERIODO_VAC;

            select coalesce(sum((FECHA_fin -  FECHA_INI)+1),0) into STRICT  l_total_dias  from PLLA_ROL_VACACIONAL 
            where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab and condicion='P';

            select  DIAS_ANHO  into STRICT l_dias_anho  from PLLA_PERIODO_VAC_TRAB where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab;

            if l_total_dias>23 then
              l_diasqueda:= 30 - l_total_dias;
              /*if l_diasqueda<>l_dias then
                  l_error:=1;
                  l_msgerror:='Se debe registra los dias restantes ('||to_char(l_diasqueda)||') días';
--                   GOTO salida_gen_vac_ade;
              end if;*/
            else

              if l_dias<l_minp1 then
                  l_error:=0;
                 -- l_msgerror:='En el periodo  se debe registrar como mínimo '||to_char(l_minp1)||' días';
                  --GOTO salida_gen_vac_ade;
              end if;
            end if;

            
            
            
            --if (l_total_dias+l_dias)>30 then
            if (l_total_dias+l_dias)>l_dias_anho then
                l_error:=1;
                l_msgerror:='Total dias no debe exceder '||l_dias_anho||', actual: '||l_total_dias+l_dias::text;
--                 GOTO salida_gen_vac_ade;
            end if;

            
           
            
            select id_tipo_suspension into STRICT l_id_tipo_suspension from plla_tipo_suspension where codsunat='23';

    
              l_id_rol_vacacion:= TO_CHAR(clock_timestamp(), 'YYYYMMDDHH24MISS')||P_ITEM::text;
              insert into PLLA_ROL_VACACIONAL(
                ID_ROL_VACACION,
                ID_PERIODO_VAC_TRAB,
                FECHA_INI,
                FECHA_FIN,
                DIAS,
                DIAS_EFECT,
                CONDICION,
                ID_ESTADO_ROL_VAC,
                FECHA_REGISTRA,
                ID_USER_REG,
                ID_TIPO_SUSPENSION,
                ID_TIPO_ROL_VAC,
                ID_SOL_VAC_ADEL_DET
              )values(
                l_id_rol_vacacion,
                l_id_periodo_vac_trab,
                P_FECHA_INI,
                P_FECHA_FIN,
                (P_FECHA_FIN -  P_FECHA_INI)+1,
                0,
                'P',
                '01',
                clock_timestamp(),
                P_ID_USER_REG,
                l_id_tipo_suspension,
                'A',
                P_ID_SOL_VAC_ADEL_DET
              );

          
          
          select coalesce(sum((FECHA_fin -  FECHA_INI)+1),0) into STRICT  l_total_dias  from PLLA_ROL_VACACIONAL 
          where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab and  condicion='P';

          update PLLA_PERIODO_VAC_TRAB set
          total_dias=l_total_dias
          where ID_PERIODO_VAC_TRAB=l_id_periodo_vac_trab;

--          <<salida_gen_vac_ade>>
       
        P_ERROR:=l_error;
        P_MSGERROR:= l_msgerror;
        END;
$body$
LANGUAGE PLPGSQL
SECURITY DEFINER
;
-- REVOKE ALL ON PROCEDURE enoc.pkg_benefits_sp_generar_vac_adelanto (P_ID_PERIODO_VAC bigint, P_ID_SOL_VAC_ADEL_DET bigint,P_ID_TRABAJADOR bigint,P_FECHA_INI timestamp(0),P_FECHA_FIN timestamp(0),P_ID_USER_REG bigint,P_ITEM bigint,P_ERROR OUT bigint,P_MSGERROR out text) FROM PUBLIC;
